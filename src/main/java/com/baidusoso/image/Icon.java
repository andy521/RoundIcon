/*
 * This Java source file was generated by the Gradle 'init' task.
 */

package com.baidusoso.image;

import java.awt.AlphaComposite;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.RenderingHints;
import java.awt.Toolkit;
import java.awt.geom.AffineTransform;
import java.awt.geom.RoundRectangle2D;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.awt.image.CropImageFilter;
import java.awt.image.FilteredImageSource;
import java.awt.image.ImageFilter;
import java.awt.image.MemoryImageSource;
import java.awt.image.PixelGrabber;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;

import javax.imageio.ImageIO;

import static com.baidusoso.image.Icon.Policy.CropAtCenter;
import static com.baidusoso.image.Icon.Policy.CropAtTop;

public class Icon {

    public static boolean ENABLE_LOGS = true;

    enum Policy {
        Scaled(0), CropAtTop(1), CropAtCenter(2), CropAtBottom(3);
        int value;

        private Policy(int val) {
            this.value = val;
        }

        public static Policy valueOf(int value) {
            switch (value) {
                case 1:
                    return CropAtTop;
                case 2:
                    return CropAtCenter;
                case 3:
                    return CropAtBottom;
                default:
                    return Scaled;
            }
        }
    }

    private static class TransformParams {
        float mXScale, mYScale;
        int mCropAtX, mCropAtY;
    }

    private static TransformParams getTransformParams(BufferedImage image, Policy policy, int targetSize) {
        if (image == null || policy == null) {
            throw new NullPointerException("Empty image or policy!!! ");
        }
        int w = image.getWidth();
        int h = image.getHeight();
        float xscale = (float) targetSize / w;
        float yscale = (float) targetSize / h;

        TransformParams params = new TransformParams();
        if (policy == Policy.Scaled) {
            params.mXScale = xscale;
            params.mYScale = yscale;
            params.mCropAtX = params.mCropAtY = 0;
        } else {
            params.mXScale = params.mYScale = Math.max(xscale, yscale);
            if (policy == CropAtTop) {
                params.mCropAtX = params.mCropAtY = 0;
            } else if (policy == CropAtCenter) {
                params.mCropAtX = xscale > yscale ? 0 : (int) (w * yscale - targetSize) / 2;
                params.mCropAtY = xscale < yscale ? 0 : (int) (h * xscale - targetSize) / 2;
            } else {
                params.mCropAtX = xscale > yscale ? 0 : (int) (w * yscale - targetSize);
                params.mCropAtY = xscale < yscale ? 0 : (int) (h * xscale - targetSize);
            }
        }
        return params;
    }

    private static InputStream getImageInputStreamByUrl(String url) {
        URL imgUrl = null;
        try {
            imgUrl = new URL(url);
            HttpURLConnection conn = (HttpURLConnection) imgUrl.openConnection();
            conn.setDoInput(true);
            conn.connect();
            return conn.getInputStream();
        } catch (MalformedURLException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    private static InputStream getImageInputStreamByFilePath(String filePath) {
        try {
            return new FileInputStream(filePath);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    private static BufferedImage getImage(String uri) throws IOException {
        if (uri == null) {
            throw new NullPointerException("uri is null!!!");
        }
        InputStream inputStream = null;
        if (uri.startsWith("http://")) {
            inputStream = getImageInputStreamByUrl(uri);
        } else {
            inputStream = getImageInputStreamByFilePath(uri);
        }
        try {
            return ImageIO.read(inputStream);
        } finally {
            if (inputStream != null) {
                try {
                    inputStream.close();
                } catch (Throwable e) {
                }
            }
        }
    }

    private static BufferedImage scaleImage(BufferedImage image, TransformParams params) {
        AffineTransform affineTransform = new AffineTransform();
        affineTransform.setToScale(params.mXScale, params.mYScale);
        AffineTransformOp affineTransformOp = new AffineTransformOp(
                affineTransform, AffineTransformOp.TYPE_BICUBIC);
        BufferedImage outputImage = new BufferedImage((int) (image.getWidth() * params.mXScale),
                (int) (image.getHeight() * params.mYScale), BufferedImage.TYPE_INT_ARGB);
        affineTransformOp.filter(image, outputImage);
        return outputImage;
    }

    private static BufferedImage scaleImage(BufferedImage image, int targetSize) {
        AffineTransform affineTransform = new AffineTransform();
        affineTransform.setToScale(targetSize * 1f / image.getWidth(), targetSize * 1f / image.getHeight());
        AffineTransformOp affineTransformOp = new AffineTransformOp(
                affineTransform, AffineTransformOp.TYPE_BICUBIC);
        BufferedImage outputImage = new BufferedImage(targetSize, targetSize, BufferedImage.TYPE_INT_ARGB);
        affineTransformOp.filter(image, outputImage);
        return outputImage;
    }

    private static BufferedImage cropImage(BufferedImage image, TransformParams params, int targetSize) {
        ImageFilter cropFilter = new CropImageFilter(params.mCropAtX, params.mCropAtY, targetSize, targetSize);
        Image img = Toolkit.getDefaultToolkit().createImage(
                new FilteredImageSource(image.getSource(), cropFilter));
        BufferedImage outputImage = new BufferedImage(targetSize, targetSize,
                BufferedImage.TYPE_INT_ARGB);

        Graphics g = outputImage.getGraphics();
        g.drawImage(img, 0, 0, null);
        g.dispose();
        return outputImage;
    }

    private static BufferedImage roundImage(BufferedImage image, int targetSize, int cornerRadius) {
        BufferedImage outputImage = new BufferedImage(targetSize, targetSize, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g2 = outputImage.createGraphics();
        g2.setComposite(AlphaComposite.Src);
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        g2.setColor(Color.WHITE);
        g2.fill(new RoundRectangle2D.Float(0, 0, targetSize, targetSize, cornerRadius, cornerRadius));
        g2.setComposite(AlphaComposite.SrcAtop);
        g2.drawImage(image, 0, 0, null);
        g2.dispose();
        return outputImage;
    }

    private static int[] getPixArray(BufferedImage im) {
        int w = im.getWidth();
        int h = im.getHeight();
        int[] pix = new int[w * h];
        PixelGrabber pg = null;
        try {
            pg = new PixelGrabber(im, 0, 0, w, h, pix, 0, w);
            if (pg.grabPixels()) {
                return pix;
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        return null;
    }

    private static int[] convertImage(int[] ImageSource, int[] backGroundPixArray, int w, int h) {
        if (backGroundPixArray == null || ImageSource == null) {
            return null;
        }
        for (int i = 0; i < ImageSource.length; i++) {
            int tmp = i + (i / w + 1) * (100 - w) - (100 - w) / 2;
            if (((ImageSource[i] & 0xFF000000) != 0) &&
                    (0xFFFFFFFF != (backGroundPixArray[tmp] & 0xFF000000))) {
                ImageSource[i] = (ImageSource[i] & 0xFFFFFF | backGroundPixArray[tmp] & 0xFF000000);
            }
        }
        return ImageSource;
    }

    private static BufferedImage circleImage(BufferedImage image, int targetSize) {
        try {
            BufferedImage shadowImage = ImageIO.read(Icon.class.getResourceAsStream(
                    "/resource/shadow.png"));
            BufferedImage backGroundImage = ImageIO.read(Icon.class.getResourceAsStream(
                    "/resource/white.png"));

            BufferedImage newImage = scaleImage(image, 90);

            int width = newImage.getWidth();
            int height = newImage.getHeight();

            int[] backGroundPixArray = getPixArray(backGroundImage);
            int[] currentPixArray = getPixArray(newImage);

            int[] resultArray = convertImage(currentPixArray, backGroundPixArray, width, height);

            Image pic = Toolkit.getDefaultToolkit().createImage(new MemoryImageSource(width, height,
                    resultArray, 0, width));

            Graphics2D tmp = shadowImage.createGraphics();
            tmp.drawImage(backGroundImage, 0, 0, null);
            tmp.drawImage(pic, 5, 0, null);
            tmp.dispose();

            return scaleImage(shadowImage,targetSize);
        } catch (IOException ex) {
            if (ENABLE_LOGS) System.out.println("error");
        }
        return null;
    }

    private static BufferedImage addPaddingToImage(BufferedImage image, int padding) {
        int fullSize = image.getWidth();
        int viewSize = fullSize - 2 * padding;
        float scale = viewSize * 1f / fullSize;
        AffineTransform affineTransform = new AffineTransform();
        affineTransform.setToScale(scale, scale);
        affineTransform.translate(padding / scale, padding / scale);
        AffineTransformOp affineTransformOp = new AffineTransformOp(
                affineTransform, AffineTransformOp.TYPE_BICUBIC);
        BufferedImage outputImage = new BufferedImage(fullSize, fullSize, BufferedImage.TYPE_INT_ARGB);
        affineTransformOp.filter(image, outputImage);
        return outputImage;
    }

    private static void showUsage() {
        System.out.println("java -jar RoundIcon.jar image [output path] [output image size] [cornerRadius] [policy:0,1,2,3] [padding]");
    }

    /**
     * {@link #generateIcon(String, String, int, int, Policy, int)} with policy = Policy.Scaled
     */
    public static boolean generateIcon(String inputPath, String outputPath, int iconSize, int cornerRadius, int padding) {
        return generateIcon(inputPath, outputPath, iconSize, cornerRadius, Policy.Scaled, padding);
    }

    /**
     * Generate icon from base by parameters
     * @param inputPath source image, it could be a local image path or http url
     * @param targetPath path for the output icon
     * @param targetSize width or height of the output icon
     * @param cornerRadius corner radius, if corner radius greater than 0, it will output round rect image, otherwise,
     *                     it will output circle image with shadow .
     * @param policy parameter will decide transform policy: which part of the original image would be transform to the round icon.
     *               Its value should be 0, 1 ,2, or 3. .
     * @param padding padding for the output icon
     * @return true - if icon was generated, false - otherwise
     */
    public static boolean generateIcon(String inputPath, String targetPath, int targetSize, int cornerRadius, Policy policy, int padding) {
        BufferedImage image = null;
        try {
            image = getImage(inputPath);
        } catch (IOException e) {
            e.printStackTrace();
        }
        if (image == null) {
            if (ENABLE_LOGS) System.out.println("Fail to get Image data!!!");
            return false;
        }
        TransformParams params = getTransformParams(image, policy, targetSize);
        BufferedImage outputImage = scaleImage(image, params);
        if (policy != Policy.Scaled) {
            outputImage = cropImage(outputImage, params, targetSize);
        }
        if (cornerRadius == 0) {
            outputImage = circleImage(outputImage, targetSize);
        } else {
            outputImage = roundImage(outputImage, targetSize, cornerRadius);
        }
        if (padding > 0) {
            outputImage = addPaddingToImage(outputImage, padding);
        }
        try {
            ImageIO.write(outputImage, "png", new File(targetPath));
        } catch (IOException e) {
            e.printStackTrace();
            return false;
        }
        if (ENABLE_LOGS) System.out.println("Done");
        return true;
    }

    public static void main(String[] args) throws Exception {
        if (args == null || args.length == 0) {
            showUsage();
            return;
        }
        String uri = args[0];
        String targetPath = "icon.png";
        if (args.length >= 2) {
            targetPath = args[1];
        }
        int targetSize = 96;
        if (args.length >= 3) {
            targetSize = Integer.parseInt(args[2]);
        }
        int cornerRadius = 0;
        if (args.length >= 4) {
            cornerRadius = Integer.parseInt(args[3]);
        }
        Policy policy = Policy.Scaled;
        if (args.length >= 5) {
            policy = Policy.valueOf(Integer.parseInt(args[4]));
        }
        int padding = 0;
        if (args.length >= 6) {
            padding = Integer.parseInt(args[5]);
        }

        generateIcon(uri, targetPath, targetSize, cornerRadius, policy, padding);
    }
}
